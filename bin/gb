#!/usr/bin/env ruby

# NOTE: This script is still volatile and hasn't been put through the ringer yet,
# if you try it and find edge cases, LMK

# These ship with Ruby, in the stdlib
require 'set'
require 'open3'      # for calling out to git
require 'io/console' # for detecting window size to decide if we should use a pager

DATE_FORMAT = 'human' # "human" and "relative" are both pretty good

Attr = Struct.new :name, :log_format, :column_heading, :default do
  alias getter name

  def setter
    @setter ||= :"#{name.to_s.chomp("?").chomp("!")}="
  end

  def get(obj)
    obj.attrs.fetch name
  end

  def set(obj, value)
    obj.attrs[name] = value
  end

  def init(obj)
    obj.attrs[name] = default
  end
end

class Branch
  def self.attrs
    @attrs ||= []
  end

  def self.attr(name, log_format:nil, column_heading:name.to_s, default:nil)
    attr = Attr.new(name, log_format, column_heading, default)
    attrs << attr
    define_method(attr.getter) { attr.get self }
    define_method(attr.setter) { |*a, **k, &b| attr.set self, *a, **k, &b }
  end

  attr :sha,       log_format: "%(objectname:short)"
  attr :local,     log_format: "%(refname)"
  attr :remote,    log_format: "%(upstream)", column_heading: 'remote /tracking'
  attr :status,    log_format: "%(upstream:track)"
  attr :author,    log_format: "%(authorname)"
  attr :committed, log_format: "%(committerdate:#{DATE_FORMAT})"
  attr :accessed
  attr :record?, column_heading: nil, default: true

  def initialize
    self.class.attrs.each { |attr| attr.init self }
  end

  def attrs
    @attrs ||= {}
  end
end

# Call out to `git` to get the branch data
log_attrs = Branch.attrs.select(&:log_format)
format    = log_attrs.map(&:log_format).join("\n")
branches = Open3.popen3 "git", "branch", "--all", "--sort=-committerdate", "--format=#{format}" do |_, out|
  out.each_slice(log_attrs.size).map do |slice|
    log_attrs.zip(slice).each_with_object(Branch.new) do |(attr, val), branch|
      attr.set branch, val.chomp
    end
  end
end

# If I have a local branch tracking a remote one, don't list the remote branch on its own
remotes = Set.new branches.map(&:remote)
branches.reject! { |b| remotes.include?(b.local) && b.local.start_with?("refs/remotes") }

# List remote branches in remote column, even if no local branches are tracking them
branches
  .select { |b| b.local.start_with? "refs/remotes" }
  .each { |b| b.local, b.remote = "", b.local }

# Don't display directory structure prefixes
branches.each do |b|
  b.local.sub!  %r(^refs/heads/), ""
  b.remote.sub! %r(^refs/(remotes|heads)/), ""
end

# Remove brackets from around the tracking status
branches.each { |b| b.status.gsub! /(?:\A\[|\]\z)/, "" }

# Use the reflog to order branches by which branches we've recently visited
visits = Open3.popen3 "git", "reflog", "--grep-reflog", "checkout: moving from", "--date", DATE_FORMAT do |_, out|
  out.each.with_object({}).with_index do |(line, visits), index|
    branch_name = line[/\S+$/]
    access_time = line[/(?<=\{)[^}]*/]
    visits[branch_name] ||= { index: index, accessed: access_time }
  end
end

initial_indexes = branches.each_with_index.to_h
branches.sort_by! do |branch|
  visit = visits[branch.local] || visits[branch.remote] || { index: visits.size, accessed: '' }
  branch.accessed = visit[:accessed]
  [visit[:index], initial_indexes[branch]]
end

# Add a header
display_attrs = Branch.attrs.select(&:column_heading)
header = display_attrs.each_with_object(Branch.new) { |a, b| a.set b, a.column_heading }
header.record = false
branches.unshift header

# Calculate column widths for padding values to the same width
sizes = display_attrs.map do |attr|
  branches.map { |b| attr.get(b).size }.max
end

# Add a line to delimit header from rows
delimiter = display_attrs.zip(sizes).each_with_object(Branch.new) do |(attr, n), branch|
  attr.set branch, '-'*n
end
delimiter.record = false
branches.unshift branches.shift, delimiter

# Add colour unless we're in a pipeline
if $stdout.tty?
  me = `git config user.name`.chomp
  remotes = `git remote`.lines.map(&:chomp)
  remote_regex = %r{\A(?:#{remotes.join '|'})/}

  color = -> branch, formatted do
    if branch.remote =~ remote_regex
      prefix, bname = $&, $'
    else
      prefix, bname = '', branch.remote
    end

    if branch.remote == "#{prefix}#{branch.local}"
      # Blue for branches whose local and remote names match
      formatted.local.sub!  branch.local, "\e[34m#{branch.local}\e[39m"
      formatted.remote.sub! branch.remote, "#{prefix}\e[34m#{branch.local}\e[39m"
    else
      # Orange if local name doesn't match remote name or remote is untracked
      formatted.local.sub!  branch.local, "\e[33m#{branch.local}\e[39m"
      formatted.remote.sub! branch.remote, "#{prefix}\e[33m#{bname}\e[39m"
    end

    if branch.status == 'gone'
      formatted.status.sub! /\bgone\b/, "\e[31mgone\e[39m"
    else
      formatted.status.gsub! /\w+/, "\e[33m\\&\e[39m"
    end

    formatted.author.sub! me, "\e[92m#{me}\e[0m" if branch.author == me
  end
else
  color = proc { }
end

# Use a pager if our output will scroll and we're not in a pipeline
if $stdout.tty?
  rows, _cols = $stdout.winsize
  if branches.size > rows
    read, write = IO.pipe
    if fork
      write.close
      $stdin.reopen read
      read.close
      exec "less", "-R" # -R allows color codes to work
    else
      read.close
      $stdout.reopen write
    end
  end
end

# Print each row
branches.each do |branch|
  formatted = display_attrs.zip(sizes).each_with_object(Branch.new) do |(attr, n), br|
    attr.set br, attr.get(branch).ljust(n)
  end
  color[branch, formatted] if branch.record?
  puts display_attrs.map { |a| a.get formatted }.join(' | ')
end
