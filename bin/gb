#!/usr/bin/env ruby

# NOTE: This script is still volatile and hasn't been put through the ringer yet,
# if you try it and find edge cases, LMK

# These ship with Ruby, in the stdlib
require 'open3'
require 'io/console'

date_format = "human" # "human" and "relative" are both pretty good
up_to_date_msg = ''   # ehh, not sure what I want it to say when they're pointing @ the same commit. I guess empty string is good enough for now

# Map of attributes, git format string to get the attr, and proc for postprocessing
attrs = [
  # [:head,    "%(HEAD)"],
  [:sha,       "%(objectname:short)"],
  [:local,     "%(refname)"],
  [:remote,    "%(upstream)"],
  [:status,    "%(upstream:track)"],
  [:author,    "%(authorname)"],
  [:committed, "%(committerdate:#{date_format})"],
  [:accessed,  "..."], # this will be filled in later b/c I don't know how to ask the log to give me this
]

# Define a combo setter/getter for each attribute
# I was previously using a struct, but then keeping track of displayable vs
# non-displayable attributes became painful, so instead I'm making methods that
# know where in the array to look
attribute_index = -1
define_singleton_method :define_setter_getter do |name, display, index=(attribute_index+=1)|
  not_set = Object.new
  define_singleton_method name do |branch, value=not_set|
    value == not_set ? branch[index] : branch[index] = value
  end
  attrs[index] ||= [name, nil, index, display]
  attrs[index][2] = index
  attrs[index][3] = display
  attrs[index]
end

attrs.each { |attr| define_setter_getter attr[0], true }

# Call out to `git` to get the branch data
format = attrs.map { |a| a[1] }.join("\n")
branches = Open3.popen3 "git", "branch", "--all", "--sort=-committerdate", "--format=#{format}" do |_, out|
  # Parse git's output into branches
  out.each_slice(attrs.size).map { |slice| slice.each &:chomp! }
end

# If I have a local branch tracking a remote one, don't list the remote branch again
remotes = branches.to_h { |b| [remote(b), true] }
branches.reject! { |b| remotes.key?(local(b)) && local(b).start_with?("refs/remotes") }

# List remote branches in remote column, even if no local branches are tracking them
branches
  .select { |b| local(b).start_with? "refs/remotes" }
  .each { |b| remote b, local(b) }
  .each { |b| local  b, "" }

# Don't display directory structure prefixes
branches.each do |b|
  local(b).sub!  %r(^refs/heads/), ""
  remote(b).sub! %r(^refs/(remotes|heads)/), ""
end

# Remove brackets from around the tracking status
branches.each { |b| status(b).gsub! /(?:\A\[|\]\z)/, "" }

# Wording for status when they're lined up
branches.each { |b| status b, up_to_date_msg if status(b).empty? }

# Use the reflog to order branches by which branches we've recently visited
visits = Open3.popen3 "git", "reflog", "--grep-reflog", "checkout: moving from", "--date", date_format do |_, out|
  out.each.with_object({}).with_index { |(line, visits), index|
    visits[line[/\S+$/]] ||= { index: index, accessed: line[/(?<=\{)[^}]*/] }
  }
end
# define_setter_getter :accessed, true
initial_indexes = branches.each_with_index.to_h
branches.sort_by! do |branch|
  visit = visits[local(branch)] || visits[remote(branch)] || { index: visits.size, accessed: nil }
  accessed branch, visit[:accessed]
  [visit[:index], initial_indexes[branch]]
end

# Track an additional attribute:
define_setter_getter :is_record, false
branches.each { |b| is_record b, true }

# Add a header
header = attrs.map(&:first).map(&:to_s)
is_record header, false
remote header, 'remote / tracking'
branches.unshift header

# Calculate column widths & format strong to pad values to match
sizes = branches.transpose.map do |col|
  col.map { |val| val.to_s.size }.max
end

# Add a line to delimit header from rows
delimiter = sizes.map { |n| '-'*n }
is_record delimiter, false
branches.unshift branches.shift, delimiter

# Add colour unless we're in a pipeline
if $stdout.tty?
  me = `git config user.name`.chomp
  remotes = `git remote`.lines.map(&:chomp)
  remote_regex = %r{\A(?:#{remotes.join '|'})/}

  color = -> branch, formatted do
    if remote(branch) =~ remote_regex
      prefix, bname = $&, $'
    else
      prefix, bname = '', remote(branch)
    end

    if remote(branch) == "#{prefix}#{local(branch)}"
      # Blue for branches whose local and remote names match
      local(formatted).sub!  local(branch), "\e[34m#{local(branch)}\e[39m"
      remote(formatted).sub! remote(branch), "#{prefix}\e[34m#{local(branch)}\e[39m"
    else
      # Orange if local name doesn't match remote name or remote is untracked
      local(formatted).sub!  local(branch), "\e[33m#{local(branch)}\e[39m"
      remote(formatted).sub! remote(branch), "#{prefix}\e[33m#{bname}\e[39m"
    end

    if status(branch) == 'gone'
      status(formatted).sub! /\bgone\b/, "\e[31mgone\e[39m"
    elsif status(branch) == up_to_date_msg
      # noop, just highlight ones that aren't up to date, no real value in
      # making this green, as it's not something I'm typically filtering by
    else
      status(formatted).gsub! /\w+/, "\e[33m\\&\e[39m"
    end

    author(formatted).sub! me, "\e[92m#{me}\e[0m" if author(branch) == me
  end
else
  color = proc { }
end

# Use a pager if our output will scroll and we're not in a pipeline
if $stdout.tty?
  rows, _cols = $stdout.winsize
  if branches.size > rows
    read, write = IO.pipe
    if fork
      write.close
      $stdin.reopen read
      read.close
      exec "less", "-R" # -R allows color codes to work
    else
      read.close
      $stdout.reopen write
    end
  end
end

# Print each row
branches.each do |branch|
  formatted = attrs
    .select { |name, _, index, display| display }
    .map { |_, _, index| branch[index].to_s.ljust(sizes[index]) }
  color[branch, formatted] if is_record(branch)
  puts formatted.join(' | ')
end
